<template>
  <main id="tapestry" ref="app" :style="background">
    <div v-if="empty && threeButtonClicked">
      <template v-if="canEdit">  
        <root-node-button @click="addRootNode"></root-node-button> 
      </template>
      <div v-else class="empty-message">The requested Tapestry is empty.</div>
    </div>
    <svg v-else id="vue-svg" :viewBox="viewBox">
      <g class="links">
        <tapestry-link
          v-for="link in links"
          :key="`${link.source}-${link.target}`"
          :source="nodes[link.source]"
          :target="nodes[link.target]"
          :link="link"
        ></tapestry-link>
      </g>
      <g v-if="!dragSelectEnabled || dragSelectReady" class="nodes">
        <tapestry-node
          v-for="(node, id) in nodes"
          :key="id"
          :node="node"
          class="node"
          :class="{ selectable: true }"
          :data-id="id"
          :root="id == selectedId"
          @dragend="updateViewBox"
          @mouseover="handleMouseover(id)"
          @mouseleave="activeNode = null"
          @mounted="dragSelectEnabled ? updateSelectableNodes(node) : null"
        ></tapestry-node>
      </g>
      <locked-tooltip
        v-if="activeNode"
        :node="nodes[activeNode]"
        :viewBox="viewBox"
      ></locked-tooltip>
    </svg>
  <div>
    <div class="strength-of-relevancy" v-if="tapestryGenerated">Strength of relevancy connections</div>
    <div class="white-box" v-if="tapestryGenerated"> <!-- v-if="tapestryGenerated" -->
      A default connection between nodes is represented in <span class="navy-blue">navy blue</span><br>
      The color of the connection represents the strength of the relevancy between grandchild nodes. It represents a correlation number - note that this number is generated by ChatGPT-3.5 after comparing the similarity of texts between two nodes.
    <br>
    <span class="correlation-text">Lower correlation</span> <span class="lighter-blue">70-79</span> <span class="medium-blue">80-89</span> <span class="darker-blue">90-100</span> <span class="correlation-text">Highest correlation</span>
    </div>
  <div class="prompt-container" v-if="promptButtonClicked || rootNodeAdded">
      <form @submit="submitUserInput">
        <button type="submit" class="prompt-submit-button">
        </button>
        <textarea class="prompt-text-field" v-model="userInput" rows="5" cols="40" placeholder="Enter a text prompt up to 1000 words to generate a Tapestry (e.g. Machine                          learning in the workplace). Do not use the ~ character in your text."></textarea>
      </form>
    </div>
    <div><!-- <div v-if="tapestryGenerated"> -->
      <form @submit="deleteNodes">
        <button type="submit" class="delete-submit-button">
          Delete All Nodes
        </button>
      </form>
    </div>
    <div id="loading" v-if="generatingTapestry">
      <img :src="LoadingGif" alt="Loading..."/>
    </div>
    <div
      v-if="dropButtonClicked || rootNodeAdded"
      class="dropzone"
      :class="{ 'dragging': dragging }"
      @dragover.prevent
      @dragenter="dragging = true"
      @dragleave="dragging = false"
      @drop="handleDrop"
    >
      <div class="upload-texts">
        <img :src="UploadPDF"/>
        <span class="upload-large-text">Upload a PDF</span> <br> 
        <span class="upload-small-text">Drag and drop or click to upload</span>    
        <br>
      </div>
      <div v-if="droppedFileName">Dropped file: {{ droppedFileName }}</div>
      <div>
        <input type="file" ref="fileInput" style="display: none" @change="handleFileSelect"/>
        <button class="select-pdf-button" @click="openFileInput">Select PDF File</button>
      </div>
    </div>
    <div v-if="empty && !threeButtonClicked" class="large-main-text">What do you want to generate your tapestry from?</div>
    <br>
    <div class="button-container" v-if="empty && (showUploadPDF || showWritePrompt || showCreateYourself)">
      <div class="feature-text">
        <span class="feature-text-bold">Features with AI/Machine Learning Integration</span>
        <br>
        (automatically generate Tapestries with edit functionality)
      </div>
      <div class="button-boxes">
        <div class="dotted-ml-box">
          <button class="upload-a-pdf-button" @click="uploadPDF" v-if="empty && showUploadPDF"> <img :src="UploadPDF"/> <br> <br> Upload a PDF</button>
          <button class="write-a-prompt-button" @click="writePrompt" v-if="empty && showWritePrompt"> <img :src="WritePrompt"/> <br> <br> Write a prompt</button>
        </div>
        <button class="create-it-yourself-button" @click="createYourself" v-if="empty && showCreateYourself"> <img :src="CreateYourself"/> <br> <br> Create it yourself</button>
      </div>
    </div>
  </div>
  </main>
</template>

<script>
import DragSelectModular from "@/utils/dragSelectModular"
import { mapMutations, mapState } from "vuex"
import TapestryNode from "./TapestryNode"
import TapestryLink from "./TapestryLink"
import RootNodeButton from "./RootNodeButton"
import LockedTooltip from "./LockedTooltip"
import Helpers from "@/utils/Helpers"
import { names } from "@/config/routes"
import * as wp from "@/services/wp"
import LoadingGif from "@/assets/loading.gif"
import UploadPDF from "@/assets/upload_pdf.png"
import WritePrompt from "@/assets/write_prompt.png"
import CreateYourself from "@/assets/create_yourself.png"
import { tapestryGeneration } from "./tapestryml" // JavaScript function

export default {
  components: {
    TapestryNode,
    TapestryLink,
    RootNodeButton,
    LockedTooltip,
  },
  props: {
    viewBox: {
      type: String,
      required: true,
    },
  },
  data() {
    return {
      dragSelectReady: false,
      activeNode: null,
      userInput: "", // taking in user input data
      generatingTapestry: false,
      promptButtonClicked: false,
      dropButtonClicked: false,
      createYourselfClicked: false,
      dragging: false,
      droppedFileName: '',
      threeButtonClicked: false,
      tapestryGenerated: false,
      showUploadPDF: true,
      showWritePrompt: true,
      showCreateYourself: true,
      rootNodeAdded: false,
      LoadingGif: LoadingGif,
      UploadPDF: UploadPDF,
      WritePrompt: WritePrompt,
      CreateYourself: CreateYourself,
      //tapestryGeneration: false,
    }
  },
  computed: {
    ...mapState(["nodes", "links", "selection", "settings", "rootId"]),
    background() {
      return this.settings.backgroundUrl
    },
     canEdit() {
       return wp.canEditTapestry()
     },
    empty() {
      return Object.keys(this.nodes).length === 0
    },
    selectedId() {
      return Number(this.$route.params.nodeId)
    },
    dragSelectEnabled() {
      return !Helpers.isTouchEnabledDevice()
    },
    editableNodes() {
      return this.nodes.length
        ? this.nodes.filter(node => this.nodeIsEditable(node))
        : this.nodes
    },
  },
  watch: {
    background: {
      immediate: true,
      handler(background) {
        document.body.style.backgroundImage = background ? `url(${background})` : ""
      },
    },
    selectedId: {
      immediate: true,
      handler(nodeId) {
        if (this.$route.name === names.APP && !this.nodes.hasOwnProperty(nodeId)) {
          this.$router.replace(
            Object.keys(this.nodes).length === 0
              ? { path: "/", query: this.$route.query }
              : {
                  name: names.APP,
                  params: { nodeId: this.rootId },
                  query: this.$route.query,
                }
          )
        }
      },
    },
  },
  mounted() {
    if (this.dragSelectEnabled) {
      DragSelectModular.initializeDragSelect(this.$refs.app, this, this.nodes)
    }
    this.updateViewBox()
    this.dragSelectReady = true

    // !!! - begin
    const tapestryGenerated = localStorage.getItem('tapestryGenerated');
  
    // Set the component's data based on the value in local storage
    this.tapestryGenerated = tapestryGenerated === 'false';
    // !!! - end

  },
  methods: {
    ...mapMutations(["select", "unselect", "clearSelection"]),
    addRootNode() {
      this.$root.$emit("add-node", null)
    },

    updateSelectableNodes() {
      DragSelectModular.updateSelectableNodes()
    },
    nodeIsEditable(node) {
      return wp.isLoggedIn() && Helpers.hasPermission(node, "edit")
    },
    updateViewBox() {
      this.$parent.updateViewBox()
    },
    handleMouseover(id) {
      const node = this.nodes[id]
      if (
        !node.accessible &&
        node.nodeType !== "grandchild" &&
        node.nodeType !== ""
      ) {
        this.activeNode = id
      }
    },
    setTapestryGenerated(value) {
      localStorage.setItem('tapestryGenerated', value ? 'true' : 'false');
    },
    uploadPDF() {
      this.dropButtonClicked = true;
      this.promptButtonClicked = false;
      this.threeButtonClicked = true;

      this.showUploadPDF = false;
      this.showWritePrompt = false;
      this.showCreateYourself = false;
    },
    writePrompt() {
      this.promptButtonClicked = true;
      this.dropButtonClicked = false;
      this.threeButtonClicked = true;

      this.showUploadPDF = false;
      this.showWritePrompt = false;
      this.showCreateYourself = false;
    },
    createYourself() {
      this.createYourselfClicked = true;
      this.threeButtonClicked = true;
      this.promptButtonClicked = false;
      this.dropButtonClicked = false;

      this.showUploadPDF = false;
      this.showWritePrompt = false;
      this.showCreateYourself = false;
    },
    submitUserInput() {
      console.log('Submitting user input:', this.userInput);
      this.generatingTapestry = true;

      // Call the tapestryGeneration function
      tapestryGeneration(this.userInput).then(() => {
        // This code will run after the tapestryGeneration function is done

        // Hide the loading icon
        this.generatingTapestry = false;
        this.setTapestryGenerated(true);

        this.refresh();
        });
        this.showUploadPDF = false;
        this.showWritePrompt = false;
        this.showCreateYourself = false;
        this.threeButtonClicked = true;
        // Put code here
    },

    deleteEntireTapestry() {
      console.log('Deleting Entire Tapestry...');
      deleteLinks(this.userInput2);
    },

    async deleteNodes() {
      for (const nodeId in this.nodes) {
        if (nodeId !== this.rootId) {
          await this.deleteNode(nodeId);
          const links = this.getNeighbouringLinks(nodeId);
          console.log("Neighbouring links:", this.getNeighbouringLinks(nodeId));
          for(const link in links) {
            await this.deleteLink({
              source: link.source,
              target: link.target,
              useClient: false,
            })
          }
        }
      }
      this.setTapestryGenerated(false);
    },
    async handleDrop(e) {
      e.preventDefault();
      const file = e.dataTransfer.files[0];
      this.handleFile(file);
    },
    handleFileSelect(e) {
      const file = e.target.files[0];
      this.handleFile(file);
    },
    openFileInput() {
      this.$refs.fileInput.click();
    },
    async handleFile(file) {
      if (file.type !== "application/pdf") {
        alert("Please select a PDF file.");
        return;
      }
      this.droppedFileName = file.name;

      const formData = new FormData();
      formData.append("file", file);
      console.log("formData:", formData);

      try {
        const response = await axios.post(
          "http://localhost:8000/extract-pdf-text",
          formData
        );
        const text = response.data;
        console.log("Text extracted:", text);
        this.generatingTapestry = true;
        tapestryGeneration(text).then(() => {
          // This code will run after the tapestryGeneration function is done

          // Hide the loading icon
          this.generatingTapestry = false;
          this.setTapestryGenerated(true);

          this.refresh(); 
          // Put code here 
        });
        this.dragging = false;
      } catch (error) {
        console.error(error);
      }
      this.showUploadPDF = false;
      this.showWritePrompt = false;
      this.showCreateYourself = false;
      this.threeButtonClicked = true; 
    },
  },
}
</script>

<style lang="scss" scoped>
#tapestry {
  .empty-message {
    margin: 30vh auto;
  }
  svg {
    position: relative;
  }
}

.upload-a-pdf-button {
  z-index: 3;
  height: 260px;
  width: 260px;
  background-color: #77AEBF;
  border-color: #77AEBF;
  color: white;
  border-radius: 15px;
  font-size: 25px;
  margin-left: 12px;

  &:hover {
    border-width: 10px;
    border-color: #006C92;
  }
}

.write-a-prompt-button {
  z-index: 3;
  height: 260px;
  width: 260px;
  background-color: #77AEBF;
  border-color: #77AEBF;
  color: white;
  border-radius: 15px;
  font-size: 25px;
  margin-left: 10px;

  &:hover {
    border-width: 10px;
    border-color: #006C92;
  }
}

.create-it-yourself-button {
  z-index: 3;
  height: 260px;
  width: 260px;
  background-color: #77AEBF;
  border-color: #77AEBF;
  color: white;
  border-radius: 15px;
  font-size: 25px;
  margin-top: 19px;
  margin-left: 12px;

  &:hover {
    border-width: 10px;
    border-color: #006C92;
  }
}

.button-container {
  display: flex;
  background-color: #D9E9EF;
  justify-content: center;
  align-items: center;
  flex-direction: column;
  text-align: center;
  width: 1000px;
  height: 500px;
  border-radius: 15px;
  position: absolute; 
  top: 50%; 
  left: 50%; 
  transform: translate(-50%, -50%);
}

/* Optionally, add some spacing between buttons */
.button-container button {
  margin-right: 15px; 
}

.strength-of-relevancy {
  height: 50px;
  width: 500px;
  background-color: white;
  border-top-left-radius: 10px;
  border-top-right-radius: 10px;
  color: #4695C2;
  font-weight: bold;
  font-size: 20px;
  top: 50%;
  margin-right: 10px;
  display: flex;
  justify-content: center;
  align-items: center;
  text-align: center;
}

.strength-of-relevancy:hover ~ .white-box {
  display: block;
}

.white-box {
  display: none;
  height: 200px;
  width: 500px;
  border-radius: 10px;
  background-color: white;
  color: #77AEBF;
  justify-content: center;
  font-weight: lighter;
  top: 50%;
  margin-right: 10px;
  }

  .navy-blue {
    color:#006C92;
    font-weight: bold;
  }

  .lighter-blue {
    color: #77AEBF;
    font-size: 20px;
    font-weight: 1000;
  }

  .medium-blue {
    color: #1DADE1;
    font-size: 20px;
    font-weight: 1000;
  }

  .darker-blue {
    color: #006C92;
    font-size: 20px;
    font-weight: 1000;
  }

  .correlation-text {
    color: #59595B;
    font-size: 15px;
  }

  .upload-large-text {
    font-size: 40px;
    font-weight: bold;
    color: white;
  }

  .upload-small-text {
    font-size: 20px;
    color: white;
  }

  .upload-texts {
    margin: 15px;
  }

  .large-main-text {
    z-index: 14;
    color: #006C92;
    font-weight: bold;
    font-size: 50px;
    position: absolute;
    top: 25%; 
    left: 50%;
    transform: translate(-50%, -50%);
    width: 1500px;
  }

  .dotted-ml-box {
    display: flex;
    width: 600px;
    height: 300px;
    border: #99C4D3 dashed;
    border-width: 10px;
    justify-content: center;
    align-items: center;
    margin-left: 15px;
  }

  .feature-text {
    margin-bottom: 20px;
    margin-left: -300px; 
    font-size: 20px;
    color: #59595B;
  }

  .feature-text-bold {
    font-weight: bolder;
    font-size: 20px;
    color: #59595B;
  }

  .button-boxes {
    display: flex;
  }
</style>